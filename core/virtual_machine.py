from compiler.code_generator.opcode import Opcode
from utils.logger import get_logger

logger = get_logger(__name__)

class VirtualMachine:
    """
    Executes a sequence of opcodes generated by the code generator.
    Handles row iteration, conditional logic, and result emission.
    """
    def __init__(self, code):
        self.code = code  # List of opcodes
        self.labels = {}
        self.instruction_pointer = 0

        self.rows = []
        self.row_cursor = -1  # Current row index -1 means no row is currently being processed
        self.current_row = None

        self.registers = []
        self.output = []
        self.current_table = None

        self._index_labels()

    def _index_labels(self):
        """
        Build a mapping from label names to instruction indices.
        This is required for JUMP and JUMP_IF instructions to work correctly.
        """
        for idx, instruction in enumerate(self.code):
            if instruction[0] == Opcode.LABEL:
                label_name = instruction[1]
                self.labels[label_name] = idx

    def run(self):
        """
        Executes the opcode plan instruction by instruction.
        """
        while self.instruction_pointer < len(self.code):
            instr = self.code[self.instruction_pointer]
            opcode, *args = instr

            logger.debug(f"IP={self.instruction_pointer}: Executing {opcode.name} {args}")

            handler = getattr(self, f"op_{opcode.name.lower()}", None)
            if not handler:
                raise RuntimeError(f"No handler for opcode: {opcode.name}")

            handler(*args)

            if opcode not in {Opcode.JUMP, Opcode.JUMP_IF_FALSE}:
                self.instruction_pointer += 1