from utils.logger import get_logger

logger = get_logger(__name__)

class Parser:
    """
    A simple SQL parser that processes a list of tokens and provides
    utility methods to navigate and interpret them.

    Attributes:
        tokens (list): List of tokens to parse.
        pos (int): Current position in the token list.
    """
    def __init__(self, tokens):
        """
        Initializes the parser with a list of tokens.

        Args:
            tokens (list): The list of tokens generated by the tokenizer.
        """
        self.tokens = tokens
        self.pos = 0

    def current_token(self):
        """
        Returns the current token without advancing the position.

        Returns:
            tuple or None: The current token if available, else None.
        """
        if self.pos < len(self.tokens):
            token = self.tokens[self.pos]
            logger.debug(f"Current token: {token}")
            return token
        logger.debug("No current token, end of input reached.")
        return None

    def advance(self):
        """
        Advances the position by one token and returns the new current token.

        Returns:
            tuple or None: The next token after advancing, or None if at end.
        """
        if self.pos < len(self.tokens):
            logger.debug(f"Advancing from token: {self.tokens[self.pos]}")
            self.pos += 1
        return self.current_token()

    def peek(self, offset=1):
        """
        Peeks ahead in the token list by a given offset.

        Args:
            offset (int, optional): How far ahead to look. Defaults to 1.

        Returns:
            tuple or None: The token at the given offset, or None if out of range.
        """
        idx = self.pos + offset
        return self.tokens[idx] if idx < len(self.tokens) else None

    def expect(self, token_type, value=None):
        """
        Ensures the current token matches the expected type and optional value.

        Args:
            token_type (str): The expected token type.
            value (str, optional): The expected token value. Defaults to None.

        Raises:
            SyntaxError: If the current token does not match.

        Returns:
            tuple: The matched token.
        """
        token = self.current_token()
        if not token:
            logger.error("Unexpected end of input")
            raise SyntaxError("Unexpected end of input")
        ttype, tval = token
        if ttype != token_type or (value is not None and tval != value):
            logger.error(f"Expected {token_type}{' '+value if value else ''} but got {ttype} {tval}")
            raise SyntaxError(f"Expected {token_type}{' '+value if value else ''} but got {ttype} {tval}")
        logger.debug(f"Expect matched: {token}")
        self.advance()
        return token

    def match(self, token_type, value=None):
        """
        If current token matches type (and value), advance and return True.

        Returns:
            bool
        """
        token = self.current_token()
        if token and token[0] == token_type and (value is None or token[1] == value):
            logger.debug(f"Matched {token}")
            self.advance()
            return True
        return False

    def parse_select_list(self):
        """
        Parses the list of columns in a SELECT clause, including '*' shorthand.

        Raises:
            SyntaxError: If no columns are found.

        Returns:
            list: Column names or '*' entry.
        """
        logger.info("Parsing SELECT list")
        cols = []
        tok = self.current_token()
        # handle SELECT *
        if tok and tok[0] == "OPERATOR" and tok[1] == "*":
            cols.append("*")
            self.advance()
        else:
            while tok:
                ttype, tval = tok
                if ttype == "IDENTIFIER":
                    cols.append(tval)
                    self.advance()
                elif ttype == "COMMA":
                    self.advance()
                else:
                    break
                tok = self.current_token()
        if not cols:
            logger.error("No columns found in SELECT list")
            raise SyntaxError("No columns found in SELECT list")
        logger.info(f"SELECT list: {cols}")
        return cols

    def parse_where_clause(self):
        """
        Parses a WHERE clause: column [op] value [{AND|OR} column [op] value ...].

        Returns:
            list: List of dicts, each representing a condition.
        """
        logger.debug("Parsing WHERE clause")
        conditions = []

        while True:
            # column
            tok = self.current_token()
            if not tok or tok[0] != "IDENTIFIER":
                raise SyntaxError("Expected column name in WHERE clause")
            col = tok[1]
            self.advance()
            # operator (possibly twoâ€char)
            op_tok = self.current_token()
            if not op_tok or op_tok[0] != "OPERATOR":
                raise SyntaxError("Expected operator in WHERE clause")
            op = op_tok[1]
            nxt = self.peek()
            if nxt and nxt[0] == "OPERATOR":
                op += nxt[1]
                self.advance()
            self.advance()
            # value
            val_tok = self.current_token()
            if not val_tok or val_tok[0] not in ("STRING", "NUMBER"):
                raise SyntaxError("Expected STRING or NUMBER in WHERE clause")
            val = val_tok[1]
            self.advance()
            conditions.append({"column": col, "operator": op, "value": val})

            # Check for AND/OR
            tok = self.current_token()
            if tok and tok[0] == "KEYWORD" and tok[1] in ("AND", "OR"):
                logic = tok[1]
                self.advance()
                # Optionally, store logic if you want to support OR as well
                conditions[-1]["logic"] = logic
                continue
            break

        logger.debug(f"WHERE clause: {conditions}")
        return conditions